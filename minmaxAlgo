import java.util.*;
import java.io.*;
import java.math.*;

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player {

    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);
        boolean boost = false;
        int dirX = 0;
        int dirY = 0;
        int thrust = 100; 
        Vector<Vector<Integer>> checkpoints = new Vector<>();
        int distMax = 0;
        boolean allCheckpointsFound= false;
        int posX = 0;
        int posY = 0;
        

        // game loop
         while (true) {
            int x = in.nextInt();
            int y = in.nextInt();
            int nextCheckpointX = in.nextInt(); // x position of the next check point
            int nextCheckpointY = in.nextInt(); // y position of the next check point
            int nextCheckpointDist = in.nextInt(); // distance to the next checkpoint
            int nextCheckpointAngle = in.nextInt(); // angle between your pod orientation and the direction of the next checkpoint
            int opponentX = in.nextInt();
            int opponentY = in.nextInt();

            System.err.println(nextCheckpointAngle);
            System.err.println(nextCheckpointDist);
            System.err.println(distMax);

            Vector<Integer> nextPoint = new Vector<>();
            nextPoint.add(nextCheckpointX);
            nextPoint.add(nextCheckpointY);

            if(checkpoints.indexOf(nextPoint) == -1){
                checkpoints.add(nextPoint);
                distMax = (distMax< nextCheckpointDist ? nextCheckpointDist : distMax) - 1000;
            }
            else if(checkpoints.indexOf(nextPoint)== 0 && checkpoints.size()>1){
                allCheckpointsFound = true;
            }

            dirX = (int) (nextCheckpointX -3*(posX==0 ? 0 : x-posX)) ;
            dirY = (int) (nextCheckpointY -3*(posY==0 ? 0 : y-posY)) ;

            if(nextCheckpointAngle > 90 || nextCheckpointAngle < -90 ){
                thrust = 20;
            }    
            else if(boost== false && -10<nextCheckpointAngle && nextCheckpointAngle<10 && nextCheckpointDist>distMax && allCheckpointsFound){
                    boost = true;
                    thrust = -1;
            }
            else if(allCheckpointsFound && nextCheckpointDist < 600){
                int index = (checkpoints.indexOf(nextPoint)==checkpoints.size()-1 ? 0 : checkpoints.indexOf(nextPoint)+1);
                dirX = (int) (checkpoints.elementAt(index).elementAt(0) -3*(posX==0 ? 0 : x-posX)) ;
                dirY = (int) (checkpoints.elementAt(index).elementAt(1) -3*(posY==0 ? 0 : y-posY)) ;
            }
            else if(nextCheckpointDist < 2400){
                thrust = nextCheckpointDist/24;
            }   
            else {
                thrust = 100 ;
            }        
            
            System.out.println(dirX + " " + dirY  + " "+ (thrust== -1 ? "BOOST" : thrust));
            posX=x;
            posY=y;
            
        }
    }
}
